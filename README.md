
# Install and run
In order to install and run this project:
* Clone the repo.
* Run `npm install` in the terminal while in the repo's folder.
* Run `npm run dev`.
* Click the `localhost:` link. On my machine it is `http://localhost:5173/`. The number might be different on your machine.

These are the standard actions you will need to perform for any project that uses Vite.

# Encrption method
My idea is a simplified version of LWE. This is a symmetric key encryption and decryption method.

So you have a vector `x` that you want to encrpyt. All the values of `x` are integers, `mod k`. `k` is some prime modulus.

To encrypt `x`, we will use a private key, `s`. `s` is simply used for pseudo random number generation (PRNG). We will hash `s` with a salt. The salt will be stored, unencrypted in our final message. The hashed key will be used as the seed for our PRNG.

We will generate a random, invertible matrix `A`, using our PRNG. Since only we know `s`, only we can know `A`. Then we will multiply `A x = y (mod k)`. Doing this `mod k` means `y` looks completely random, and the attacker can't guess `A`, even if they know `x`.

Well, maybe there is some way to find `A` if they know `x`. And most the time the attacker won't even know `x`, since that is the original message which they are trying to find. So we'll um, **up the difficulty!**

After calculating our encrypted vector y, we will pass each value through a non-linear lookup table (S-Box) generated by our PRNG. This table maps each integer mod $k$ to a different, shuffled integer in the same range. Unlike the matrix multiplication, this step cannot be reversed using simple linear algebra. Next, weâ€™ll randomly cycle the values in the vector.

We will repeat this process - matrix, S-Box, and cycle - for several rounds. The combination of the matrix (which mixes the values together) and the S-Box (which changes the values unpredictably) creates a 'substitution-permutation' effect. This ensures that even a small change in our secret key or message results in a completely different ciphertext, making it impossible for an attacker to use Gaussian elimination to find our matrix.

Decrypting is as simple as doing the steps in reverse. The S-Box will be one-to-one, the cycles can just be negated, and the matrix `A` can just be inverted.

In conclusion, we encrypt a vector `x` into a vector `y`, and salt. `y` is the same size as `x`, so this just slightly increases the message length.

This is much simpler and faster than both LWE and RSA. And I believe it is just as secure as LWE. I think the matrix and modulus don't even to be that big, meaning this could easily be run on the CPU of any device. And obviously, setting up a GPU to run this is easy. The only downside, is this a symmetric key. So no ability to "sign" the message `x`, and no public key. Perhaps this system could me modified to do those things? I don't know. I'm not that good at math.




